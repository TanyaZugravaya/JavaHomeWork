1. Принцип единственной ответственности (Single Responsibility Principle - SRP):

Класс Calculator в текущей реализации выполняет несколько различных функций, таких как суммирование, умножение, деление.
Чтобы следовать принципу SRP, мы можем разделить эти функции на отдельные
классы, каждый из которых будет отвечать только за одну операцию. Создадим отдельные классы
SumCalculator, MultiplyCalculator, DivideCalculator, каждый из которых будет реализовывать
соответствующую функцию.

2. Принцип открытости/закрытости (Open/Closed Principle - OCP):

В текущей реализации класс Calculator имеет фиксированный набор операций. Если мы захотим добавить новую операцию, нам
придется изменять код класса Calculator. Чтобы следовать принципу OCP, мы можем использовать полиморфизм и создать
интерфейс Operation, который будет определять метод calculate(). Затем каждый отдельный класс,
реализующий конкретную операцию, будет реализовывать этот метод по-своему. Таким образом, мы сможем добавлять новые
операции, не изменяя код класса Calculator.

3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP):

Поскольку мы разделили функции sum, multiply и divide на отдельные классы, мы должны убедиться, что каждый из этих
классов может быть использован вместо базового класса Calculator без изменения поведения программы. То есть, любой код,
который использует Calculator, должен работать корректно с экземплярами классов SumCalculator, MultiplyCalculator и
DivideCalculator.

4. Принцип разделения интерфейса (Interface Segregation Principle - ISP):

Поскольку мы создаем отдельные классы для каждой операции, мы можем определить отдельные интерфейсы для каждой операции.
Таким образом, клиентский код сможет использовать только необходимые интерфейсы, не зависимо от того, какие операции доступны.
Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
   